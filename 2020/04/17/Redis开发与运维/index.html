<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"supermoonie.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一、初识Redis1.1 Redis特性 速度快：10万&#x2F;秒 基于键值对的数据结构服务器 丰富的功能 简单稳定 客户端语言多 持久化：RDB 和 AOF 主从复制 高可用和分布式">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis开发与运维">
<meta property="og:url" content="https://supermoonie.github.io/2020/04/17/Redis%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/index.html">
<meta property="og:site_name" content="supermoonie的笔记">
<meta property="og:description" content="一、初识Redis1.1 Redis特性 速度快：10万&#x2F;秒 基于键值对的数据结构服务器 丰富的功能 简单稳定 客户端语言多 持久化：RDB 和 AOF 主从复制 高可用和分布式">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-04-17T14:37:20.000Z">
<meta property="article:modified_time" content="2022-03-16T07:06:59.468Z">
<meta property="article:author" content="supermoonie">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://supermoonie.github.io/2020/04/17/Redis%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis开发与运维 | supermoonie的笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">supermoonie的笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/supermoonie" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://supermoonie.github.io/2020/04/17/Redis%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="supermoonie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="supermoonie的笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis开发与运维
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-17 22:37:20" itemprop="dateCreated datePublished" datetime="2020-04-17T22:37:20+08:00">2020-04-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">分布式组件</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、初识Redis"><a href="#一、初识Redis" class="headerlink" title="一、初识Redis"></a>一、初识Redis</h2><h3 id="1-1-Redis特性"><a href="#1-1-Redis特性" class="headerlink" title="1.1 Redis特性"></a>1.1 Redis特性</h3><ul>
<li>速度快：10万/秒</li>
<li>基于键值对的数据结构服务器</li>
<li>丰富的功能</li>
<li>简单稳定</li>
<li>客户端语言多</li>
<li>持久化：RDB 和 AOF</li>
<li>主从复制</li>
<li>高可用和分布式<a id="more"></a>
</li>
</ul>
<h3 id="1-2-用好Redis的建议"><a href="#1-2-用好Redis的建议" class="headerlink" title="1.2 用好Redis的建议"></a>1.2 用好Redis的建议</h3><ol>
<li>勿当作黑盒使用</li>
<li>阅读源码</li>
</ol>
<h3 id="1-3-Redis-基本操作"><a href="#1-3-Redis-基本操作" class="headerlink" title="1.3 Redis 基本操作"></a>1.3 Redis 基本操作</h3><h4 id="1-3-1-配置、启动、操作、关闭"><a href="#1-3-1-配置、启动、操作、关闭" class="headerlink" title="1.3.1 配置、启动、操作、关闭"></a>1.3.1 配置、启动、操作、关闭</h4><p>Redis 可执行文件说明：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>可执行文件</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>redis-server</td>
<td>启动Redis</td>
</tr>
<tr>
<td>redis-cli</td>
<td>Redis 命令行客户端</td>
</tr>
<tr>
<td>redis-benchmark</td>
<td>Redis 基准测试工具</td>
</tr>
<tr>
<td>redis-check-aof</td>
<td>Redis AOF 持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-check-dump</td>
<td>Redis RDB 持久化文件检测和修复工具</td>
</tr>
<tr>
<td>redis-sentinel</td>
<td>启动 Redis Sentinel</td>
</tr>
</tbody>
</table>
</div>
<p>Redis 基础配置：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>配置名</th>
<th>配置说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>port</td>
<td>端口</td>
</tr>
<tr>
<td>logfile</td>
<td>日志文件</td>
</tr>
<tr>
<td>dir</td>
<td>Redis 工作目录（存放持久化文件和日志文件）</td>
</tr>
<tr>
<td>daemonize</td>
<td>是否以守护进程的方式启动Redis</td>
</tr>
</tbody>
</table>
</div>
<p>停止 Redis 服务：<br><code>redis-cli shutdown</code> 用来停止Redis 服务，三点注意：</p>
<ul>
<li>Redis 关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式</li>
<li>除了<code>shutdown</code> 命令外，还可以通过<code>kill</code> 进程号的方式关掉Redis，但不可使用 <code>kill -9</code> 强制杀死Redis服务，不但不会做持久化操作，还会造成缓冲区等资源不能被优雅关闭，极端情况下会造成AOF和复制丢失数据的情况。</li>
<li><code>shutdown</code> 还有一个参数，代表是否在关闭Redis前，生成持久化文件：<code>redis-cli shutdown nosave|save</code></li>
</ul>
<h2 id="二、API的理解和使用"><a href="#二、API的理解和使用" class="headerlink" title="二、API的理解和使用"></a>二、API的理解和使用</h2><h3 id="2-1-全局命令"><a href="#2-1-全局命令" class="headerlink" title="2.1 全局命令"></a>2.1 全局命令</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>keys *</td>
<td>查看所有键</td>
</tr>
<tr>
<td>dbsize</td>
<td>键总数，不会遍历所有键，而是直接获取Redis内置的键总数变量</td>
</tr>
<tr>
<td>exists key</td>
<td>检查键是否存在</td>
</tr>
<tr>
<td>del key [key …]</td>
<td>删除键</td>
</tr>
<tr>
<td>expire key seconds</td>
<td>键过期</td>
</tr>
<tr>
<td>ttl key</td>
<td>查看键的过期时间</td>
</tr>
<tr>
<td>type key</td>
<td>键的数据结构类型</td>
</tr>
<tr>
<td>object encoding key</td>
<td>查询内部编码</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-2-数据结构和内部编码"><a href="#2-2-数据结构和内部编码" class="headerlink" title="2.2 数据结构和内部编码"></a>2.2 数据结构和内部编码</h3><pre class="mermaid">  graph LR
    key --> string
    key --> hash
    key --> list
    key --> set
    key --> zset
    string --> raw
    string --> int
    string --> embstr
    hash --> hashtable_1[hashtable]
    hash --> ziplist_1[ziplist]
    list --> linkedlist
    list --> ziplist_2[ziplist]
    set --> hashtable_2[hashtable]
    set --> intset
    zset --> skiplist
    zset --> ziplist_3[ziplist]</pre>

<p>Redis这样设计的好处：</p>
<ul>
<li>可以改进内部编码，对外数据结构和命令没影响，例如Reids3.2的quicklist，结合了 ziplist 和 linkedlist 两者的优势</li>
<li>多种内部编码实现可以在不同场景下发挥各自的优势</li>
</ul>
<h3 id="2-3-单线程架构"><a href="#2-3-单线程架构" class="headerlink" title="2.3 单线程架构"></a>2.3 单线程架构</h3><p>单线程为什么这么快？</p>
<ul>
<li>纯内存访问</li>
<li>非阻塞I/O</li>
<li>单线程避免了线程切换和竞态的消耗</li>
</ul>
<h3 id="2-4-字符串"><a href="#2-4-字符串" class="headerlink" title="2.4 字符串"></a>2.4 字符串</h3><h4 id="2-4-1-字符串类型常用命令"><a href="#2-4-1-字符串类型常用命令" class="headerlink" title="2.4.1 字符串类型常用命令"></a>2.4.1 字符串类型常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>set key value [ex seconds] [px milliseconds] [nx xx]</td>
<td>设置值</td>
</tr>
<tr>
<td>setnx</td>
<td>存在设置失败</td>
</tr>
<tr>
<td>setex</td>
<td>存在才能设置成功</td>
</tr>
<tr>
<td>get key</td>
<td>获取值</td>
</tr>
<tr>
<td>mset key value [key value …]</td>
<td>批量设置值</td>
</tr>
<tr>
<td>mget key [key …]</td>
<td>批量获取值</td>
</tr>
<tr>
<td>incr key</td>
<td>自增操作，值不是整数返回错误，键不存在按照 0 自增</td>
</tr>
<tr>
<td>decr key</td>
<td>自减操作</td>
</tr>
<tr>
<td>incrby decrby incrbyfloat</td>
<td>根据数值自增自减</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-4-2-字符串类型不常用命令"><a href="#2-4-2-字符串类型不常用命令" class="headerlink" title="2.4.2 字符串类型不常用命令"></a>2.4.2 字符串类型不常用命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>append key value</td>
<td>追加值</td>
</tr>
<tr>
<td>strlen key</td>
<td>字符串长度</td>
</tr>
<tr>
<td>getset key value</td>
<td>设置并返回原值</td>
</tr>
<tr>
<td>setrange key offset value</td>
<td>设置指定位置的字符</td>
</tr>
<tr>
<td>getrange key start end</td>
<td>获取部分字符串</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-4-3-字符串内部编码"><a href="#2-4-3-字符串内部编码" class="headerlink" title="2.4.3 字符串内部编码"></a>2.4.3 字符串内部编码</h4><ul>
<li>int：8 个字节的长整型</li>
<li>embstr：小于等于 39 个字节的字符串</li>
<li>raw：大于 39 个字符的字符串</li>
</ul>
<h3 id="2-5-哈希"><a href="#2-5-哈希" class="headerlink" title="2.5 哈希"></a>2.5 哈希</h3><h4 id="2-5-1-哈希命令"><a href="#2-5-1-哈希命令" class="headerlink" title="2.5.1 哈希命令"></a>2.5.1 哈希命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>hset key field value</td>
<td>设置值</td>
</tr>
<tr>
<td>hget key field</td>
<td>获取值</td>
</tr>
<tr>
<td>hdel key field [field …]</td>
<td>删除field</td>
</tr>
<tr>
<td>hlen key</td>
<td>计算field 个数</td>
</tr>
<tr>
<td>hmget key field [field …]</td>
<td>批量获取field-value</td>
</tr>
<tr>
<td>hmset key field value [field value …]</td>
<td>批量设置field-value</td>
</tr>
<tr>
<td>hexists key field</td>
<td>判断field 是否存在</td>
</tr>
<tr>
<td>hkeys key</td>
<td>获取所有field</td>
</tr>
<tr>
<td>hvals key</td>
<td>获取所有value</td>
</tr>
<tr>
<td>hgetall key</td>
<td>获取所有的field-value</td>
</tr>
<tr>
<td>hincrby hincrbyfloat key field</td>
<td>field 自增</td>
</tr>
<tr>
<td>hstrlen key field</td>
<td>计算value 的字符串长度</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-5-2-内部编码"><a href="#2-5-2-内部编码" class="headerlink" title="2.5.2 内部编码"></a>2.5.2 内部编码</h4><ul>
<li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个），同时所有值都小于hash-max-ziplist-value配置（默认64字节）时，Redis 会使用ziplist 作为哈希的内部实现。</li>
<li>hashtable（哈希表）：当哈希类型无法满足ziplist 的条件时，Redis 会使用hashtable 作为哈希的内部实现，因为此时ziplist 的读写效率会下降，而hashtable 的读写时间复杂度为O(1)。</li>
</ul>
<h3 id="2-6-列表"><a href="#2-6-列表" class="headerlink" title="2.6 列表"></a>2.6 列表</h3><h4 id="2-6-1-列表的两个特点："><a href="#2-6-1-列表的两个特点：" class="headerlink" title="2.6.1 列表的两个特点："></a>2.6.1 列表的两个特点：</h4><ul>
<li>列表中的元素是有序的</li>
<li>列表中的元素可以是重复的</li>
</ul>
<h4 id="2-6-2-命令"><a href="#2-6-2-命令" class="headerlink" title="2.6.2 命令"></a>2.6.2 命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>rpush lpush key value [value …]</td>
<td>添加</td>
</tr>
<tr>
<td>linsert key (before after) pivot value</td>
<td>插入</td>
</tr>
<tr>
<td>lrange key start end</td>
<td>查找</td>
</tr>
<tr>
<td>lindex key index</td>
<td>获取列表指定索引下表的元素</td>
</tr>
<tr>
<td>llen key</td>
<td>获取列表长度</td>
</tr>
<tr>
<td>lpop rpop key</td>
<td>弹出元素</td>
</tr>
<tr>
<td>lrem key count value</td>
<td>删除指定元素，count&gt;0，从左到右；count&lt;0从右到左 删除最多count个元素；count=0，删除所有</td>
</tr>
<tr>
<td>ltrim key start end</td>
<td>按照索引范围剪切列表</td>
</tr>
<tr>
<td>lset key index newValue</td>
<td>修改</td>
</tr>
<tr>
<td>blpop brpop key [key …] timeout</td>
<td>阻塞操作</td>
</tr>
</tbody>
</table>
</div>
<h4 id="2-6-3-内部编码"><a href="#2-6-3-内部编码" class="headerlink" title="2.6.3 内部编码"></a>2.6.3 内部编码</h4><ul>
<li>ziplist</li>
<li>linkedlist</li>
</ul>
<h4 id="2-6-4-使用场景"><a href="#2-6-4-使用场景" class="headerlink" title="2.6.4 使用场景"></a>2.6.4 使用场景</h4><ul>
<li>消息队列</li>
<li>文章列表</li>
<li>lpush + lpop = Stack（栈）</li>
<li>lpush + rpop = Queue（队列）</li>
<li>lpush + ltrim = Capped Collection（有限集合）</li>
<li>lpush + brpop = Message Queue（消息队列）</li>
</ul>
<h3 id="2-7-集合"><a href="#2-7-集合" class="headerlink" title="2.7 集合"></a>2.7 集合</h3><p>  Redis 除了支持集合内的增删改查，同时还支持多个结合取交集、并集、差集。</p>
<h4 id="2-7-1-命令"><a href="#2-7-1-命令" class="headerlink" title="2.7.1 命令"></a>2.7.1 命令</h4><p>集合内操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>sadd key ele [ele …]</td>
<td>添加元素</td>
</tr>
<tr>
<td>srem key ele [ele …]</td>
<td>删除元素</td>
</tr>
<tr>
<td>scard key</td>
<td>计算元素个数</td>
</tr>
<tr>
<td>sismember key ele</td>
<td>判断元素是否在集合中</td>
</tr>
<tr>
<td>srandmember key [count:1]</td>
<td>随机从集合返回指定个数元素</td>
</tr>
<tr>
<td>spop key</td>
<td>从集合随机弹出一个元素</td>
</tr>
<tr>
<td>smember key</td>
<td>获取所有元素</td>
</tr>
</tbody>
</table>
</div>
<p>集合间操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>sinter key [key …]</td>
<td>求多个结合的交集</td>
</tr>
<tr>
<td>suinon key [key …]</td>
<td>求多个结合的并集</td>
</tr>
<tr>
<td>sdiff key [key …]</td>
<td>求多个集合的差集</td>
</tr>
<tr>
<td>sinterstore sunionstore sdiffstore destination key [key …]</td>
<td>将交集、并集、差集的结果保存</td>
</tr>
</tbody>
</table>
</div>
<p>集合间的运算在元素较多的情况下会比较耗时，Redis 提供了 store 命令将集合间交集、并集、差集的结果保存在 destination key 中。</p>
<h4 id="2-7-2-内部编码"><a href="#2-7-2-内部编码" class="headerlink" title="2.7.2 内部编码"></a>2.7.2 内部编码</h4><ul>
<li>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis使用intset 作为集合的内部实现</li>
<li>hashtable（哈希表）：当集合类型无法满足intset 条件时，Redis 会使用hashtable 作为集合的内部实现</li>
</ul>
<h4 id="2-7-3-使用场景"><a href="#2-7-3-使用场景" class="headerlink" title="2.7.3 使用场景"></a>2.7.3 使用场景</h4><ul>
<li>标签</li>
</ul>
<h3 id="2-8-有序集合"><a href="#2-8-有序集合" class="headerlink" title="2.8 有序集合"></a>2.8 有序集合</h3><p>  集合内元素不可重复，但可以排序。它给每个元素设置一个分数（score）作为排序的依据。</p>
<h4 id="2-8-1-命令"><a href="#2-8-1-命令" class="headerlink" title="2.8.1 命令"></a>2.8.1 命令</h4><p>集合内：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>zadd key score memeber [score memeber …]</td>
<td>添加成员</td>
</tr>
<tr>
<td>zcard key</td>
<td>计算成员个数</td>
</tr>
<tr>
<td>zscore key member</td>
<td>计算某个成员的分数</td>
</tr>
<tr>
<td>zrank zrevrank key member</td>
<td>计算成员的排名</td>
</tr>
<tr>
<td>zrem key memeber [member …]</td>
<td>删除成员</td>
</tr>
<tr>
<td>zincrby key increment member</td>
<td>增加成员的分数</td>
</tr>
<tr>
<td>zrange zrevrange key start end [withscores]</td>
<td>返回指定排名范围的成员</td>
</tr>
<tr>
<td>zrangebyscore zrevrangebyscore key max min [withscores] [limit offset count]</td>
<td>返回指定分数范围的成员</td>
</tr>
<tr>
<td>zcount key min max</td>
<td>返回指定分数范围成员个数</td>
</tr>
<tr>
<td>zremrangebyrank key start end</td>
<td>删除指定排名内的升序元素</td>
</tr>
<tr>
<td>zremrangebyscore key min max</td>
<td>删除指定分数范围的成员</td>
</tr>
</tbody>
</table>
</div>
<p>Redis3.2为zadd添加了nx、xx、ch、incr 四个选项：</p>
<ul>
<li>nx：member 必须不存在才能设置成功，用于添加</li>
<li>xx：member 必须存在才能设置成功，用于更新</li>
<li>ch：返回此次操作后，有序集合元素和分数变化的个数</li>
<li>incr：对score做增加，相当于zincrby</li>
</ul>
<p>集合间的操作</p>
<ul>
<li>交集：<br><code>zinterstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code><ul>
<li>destination：交集计算结果保存在这个键</li>
<li>numkeys：需要做交集计算键的个数</li>
<li>key[key …]：需要做交集计算的键</li>
<li>weights weight[weight …]：每个键的权重，每个键中的每个member 会将自己分数乘以这个权重，每个键的权重默认是 1</li>
<li>aggregate sum|min|max：计算成员交集后，分值可以按照sum、min、max 做汇总，默认是sum</li>
</ul>
</li>
<li>并集：<br><code>zunionstore destination numkeys key [key ...] [weights weight [weight ...]] [aggregate sum|min|max]</code></li>
</ul>
<h4 id="2-8-2-内部编码"><a href="#2-8-2-内部编码" class="headerlink" title="2.8.2 内部编码"></a>2.8.2 内部编码</h4><ul>
<li>ziplist（压缩列表）：当有序元素的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist 作为有序集合的内部实现</li>
<li>skiplist（跳跃表）：当ziplist 条件不满足时，有序集合使用skiplist作为内部实现</li>
</ul>
<h4 id="2-8-3-使用场景"><a href="#2-8-3-使用场景" class="headerlink" title="2.8.3 使用场景"></a>2.8.3 使用场景</h4><ul>
<li>点赞数</li>
<li>前十名</li>
<li>用户分数</li>
</ul>
<h3 id="2-9-键管理"><a href="#2-9-键管理" class="headerlink" title="2.9 键管理"></a>2.9 键管理</h3><h4 id="2-9-1-单个键管理"><a href="#2-9-1-单个键管理" class="headerlink" title="2.9.1 单个键管理"></a>2.9.1 单个键管理</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>rename key newkey</td>
<td>键重命名</td>
</tr>
<tr>
<td>renamenx key newkey</td>
<td>newkey 不存在时重命名</td>
</tr>
<tr>
<td>randomkey</td>
<td>随机返回一个键</td>
</tr>
<tr>
<td>expire key seconds</td>
<td>键在seconds 秒后过期</td>
</tr>
<tr>
<td>expireat key timestamp</td>
<td>键在秒级时间戳timestamp 后过期</td>
</tr>
<tr>
<td>pexpire key milliseconds</td>
<td>键在milliseconds 毫秒后过期</td>
</tr>
<tr>
<td>pexpireat key milliseconds-timestamp</td>
<td>键在毫秒级时间戳timestamp 后过期</td>
</tr>
<tr>
<td>move key db</td>
<td>键内部迁移</td>
</tr>
<tr>
<td>dump key</td>
<td>键值序列化，采用RDB格式</td>
</tr>
<tr>
<td>restore key ttl value</td>
<td>反序列化键值</td>
</tr>
<tr>
<td>migrate host port (key “”) destination-db timeout [copy] [replace] [keys key [key …]]</td>
<td>Redis 实例间进行数据迁移</td>
</tr>
</tbody>
</table>
</div>
<p>Redis过期命令注意点：</p>
<ul>
<li>expire key的键不存在，返回结果为 0</li>
<li>过期时间如果为负值，键会立即被删除</li>
<li>persist 可以将键的过期时间清除</li>
<li>对于字符串类型键，set 命令会去掉过期时间</li>
<li>Redis 不支持二级数据结构内部元素的过期功能</li>
<li>setex 命令作为set+expire的组合，不但是原子操作，同时减少了一次网络通讯的时间</li>
</ul>
<p>migrate 参数：</p>
<ul>
<li>host：目标Redis 的IP地址</li>
<li>port：目标Redis 的端口</li>
<li>key|””：Redis3.0.6之前，只支持迁移一个键，Redis3.0.6 之后支持迁移多个键，需要迁移多个键时，为空字符串“”</li>
<li>destination：目标Redis 的数据库索引</li>
<li>timeout：迁移的超时时间（毫秒）</li>
<li>[copy]：添加后，迁移不删除源键</li>
<li>[replace]：添加后，不管目标Redis 是否存在该键都会正常迁移并进行数据覆盖</li>
<li>[keys key[key …]]：迁移多个键</li>
</ul>
<h4 id="2-9-2-遍历键"><a href="#2-9-2-遍历键" class="headerlink" title="2.9.2 遍历键"></a>2.9.2 遍历键</h4><ul>
<li><code>keys pattern</code>：全量遍历键<br>keys 命令可能会造成Redis 阻塞，不建议使用，当需要遍历键时：<ul>
<li>在一个不对外提供的Redis 从节点上执行，不会阻塞到客户端的请求，但会影响主从复制</li>
<li>如果确认键值总数确实比较少，可以执行该命令</li>
<li>使用scan 命令，可以有效防止阻塞</li>
</ul>
</li>
<li><code>scan cursor [match pattern] [count number]</code>：渐进式遍历<ul>
<li>curosr：必须参数，每次scan 遍历完都会返回当前游标的值，知道游标值为0，表示遍历结束</li>
<li>match pattern：可选参数，匹配正则</li>
<li>count number：可选参数，每次要遍历的键个数，默认是 10</li>
</ul>
</li>
</ul>
<p>除了scan 以外，Redis还提供了面向哈希、集合、有序列表的扫描遍历命令：hscan、sscan、zscan</p>
<h4 id="2-9-3-数据库管理"><a href="#2-9-3-数据库管理" class="headerlink" title="2.9.3 数据库管理"></a>2.9.3 数据库管理</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>select dbIndex</td>
<td>切换数据库，Redis默认配置中有16个数据库</td>
</tr>
<tr>
<td>flushdb</td>
<td>清除当前数据库</td>
</tr>
<tr>
<td>flushall</td>
<td>清除所有数据库</td>
</tr>
</tbody>
</table>
</div>
<p>  <strong>注意</strong>：Redis 的分布式实现Redis Cluster 只允许使用 0 号数据库，原因：</p>
<ul>
<li>Redis 单线程，多数据库仍然使用一个CPU，彼此之间还是会有影响</li>
<li>多数据库的使用方式，会让调试和运维不同业务的数据库变得困难，比如一个慢查询，仍然会影响其他数据库</li>
<li>部分Redis 的客户端根本不支持这种方式，即使支持，在开发时来回切换数字形势的数据库，容易弄乱</li>
</ul>
<h2 id="三、小功能大用处"><a href="#三、小功能大用处" class="headerlink" title="三、小功能大用处"></a>三、小功能大用处</h2><h3 id="3-1-慢查询分析"><a href="#3-1-慢查询分析" class="headerlink" title="3.1 慢查询分析"></a>3.1 慢查询分析</h3><p>Redis 提供了<code>slowlog-log-slower-than</code> 来设置阀值（微妙，默认 10000，=0时会记录所有的命令，<0时不会进行记录） `slowlog-max-len` 设置慢查询日志的最大条数
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">config set slowlog-log-slower-than 20000</span><br><span class="line">config set slowlog-max-len 1000</span><br><span class="line">config rewrite</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取慢查询日志</span></span><br><span class="line">slowlog get [n]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取慢查询日志列表当前的长度</span></span><br><span class="line">slowlog len</span><br><span class="line"><span class="meta">#</span><span class="bash"> 慢查询日志重置</span></span><br><span class="line">slowlog reset</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-redis-cli-详解"><a href="#3-2-redis-cli-详解" class="headerlink" title="3.2 redis-cli 详解"></a>3.2 redis-cli 详解</h3><div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-r</td>
<td>命令执行多次</td>
</tr>
<tr>
<td>-i</td>
<td>每隔几秒执行一次</td>
</tr>
<tr>
<td>-x</td>
<td>从标准输入读取数据作为最后一个参数</td>
</tr>
<tr>
<td>-c</td>
<td>连接Redis Cluster 节点时使用</td>
</tr>
<tr>
<td>-a</td>
<td>Redis 配置了命令时使用</td>
</tr>
<tr>
<td>—scan 和 —pattern</td>
<td>用于扫描指定模式的键</td>
</tr>
<tr>
<td>—slave</td>
<td>把当前客户端模拟成当前Redis 节点的从节点</td>
</tr>
<tr>
<td>—rdb</td>
<td>请求Redis实例生成并发送RDB持久化文件保存到本地</td>
</tr>
<tr>
<td>—pipe</td>
<td>批量执行Redis 命令</td>
</tr>
<tr>
<td>—bigkeys</td>
<td>使用scan 命令对Redis 的键进行采样，找出内存占用较大的键值</td>
</tr>
<tr>
<td>—eval</td>
<td>执行Lua 脚本</td>
</tr>
<tr>
<td>—latency</td>
<td>检测网络延迟</td>
</tr>
<tr>
<td>—latency-history</td>
<td>分时段了解延迟信息</td>
</tr>
<tr>
<td>—latency-dist</td>
<td>使用统计图表输出延迟统计信息</td>
</tr>
<tr>
<td>—stat</td>
<td>实时获取Redis 的重要统计信息</td>
</tr>
<tr>
<td>—no-raw</td>
<td>要求命令的返回结果必须是原始的格式</td>
</tr>
<tr>
<td>—raw</td>
<td>要求命令的返回结果是转换后的格式</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-3-redis-server-详解"><a href="#3-3-redis-server-详解" class="headerlink" title="3.3 redis-server 详解"></a>3.3 redis-server 详解</h3><p>参数 <code>--test-memory</code> 用来检测当前系统能否稳定的分配指定容量的内存给Redis</p>
<h3 id="3-4-redis-benchmark-详解"><a href="#3-4-redis-benchmark-详解" class="headerlink" title="3.4 redis-benchmark 详解"></a>3.4 redis-benchmark 详解</h3><p>redis-benchmark 可以为Redis做基准性能测试</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>客户端的并发数（默认50）</td>
</tr>
<tr>
<td>-n</td>
<td>客户端请求总量（默认100000）</td>
</tr>
<tr>
<td>-r</td>
<td>插入随机的键做测试</td>
</tr>
<tr>
<td>-P</td>
<td>每个请求pipeline 的数据量（默认1）</td>
</tr>
<tr>
<td>-k</td>
<td>是否使用keepalive，1为使用，0为不使用</td>
</tr>
<tr>
<td>-t</td>
<td>对指定命令进行基准测试</td>
</tr>
<tr>
<td>—csv</td>
<td>将结果按照csv格式输出</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-5-Pipeline"><a href="#3-5-Pipeline" class="headerlink" title="3.5 Pipeline"></a>3.5 Pipeline</h3><p>有效节约RTT（Round Trip Time，往返时间）</p>
<h3 id="3-6-事务与Lua"><a href="#3-6-事务与Lua" class="headerlink" title="3.6 事务与Lua"></a>3.6 事务与Lua</h3><p>Redis 提供了简单的事务功能，将一组需要一起执行的命令放到mulit 和 exec 两个命令之间，multi 代表事务开始，exec 代表事务结束。</p>
<h4 id="3-6-1-不同错误下的处理机制"><a href="#3-6-1-不同错误下的处理机制" class="headerlink" title="3.6.1 不同错误下的处理机制"></a>3.6.1 不同错误下的处理机制</h4><ol>
<li>命令错误：整个事务无法执行</li>
<li>运行时异常：不支持回滚</li>
</ol>
<h4 id="3-6-2-Lua"><a href="#3-6-2-Lua" class="headerlink" title="3.6.2 Lua"></a>3.6.2 Lua</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 没有local代表是全局变量</span></span><br><span class="line"><span class="keyword">local</span> strings val = <span class="string">"world"</span></span><br><span class="line"><span class="built_in">print</span>(val)</span><br><span class="line"><span class="comment">-- 表格，下标从 1 开始</span></span><br><span class="line"><span class="keyword">local</span> tables myArray = &#123;<span class="string">"redis"</span>, <span class="string">"jedis"</span>, <span class="literal">true</span>, <span class="number">88.0</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(myArray[<span class="number">3</span>])</span><br><span class="line"><span class="comment">-- for循环</span></span><br><span class="line"><span class="keyword">local</span> int sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">100</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sum = sum + i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(sum)</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #myArray</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(myArray[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- ipairs函数，返回索引下标和值</span></span><br><span class="line"><span class="keyword">for</span> index,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(myArray)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(index)</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- while</span></span><br><span class="line"><span class="keyword">local</span> int sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> int i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">100</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    sum = sum + <span class="number">1</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(sum)</span><br><span class="line"><span class="comment">-- if else</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, #myArray</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> myArray[i] == <span class="string">"jedis"</span></span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"true"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">-- do nothing</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 哈希</span></span><br><span class="line"><span class="keyword">local</span> tables user_1 = &#123;age = <span class="number">28</span>, name = <span class="string">"tom"</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"user_1 age is"</span> .. user_1[<span class="string">"age"</span>])</span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> <span class="built_in">pairs</span>(user_1)</span><br><span class="line"><span class="keyword">do</span> <span class="built_in">print</span>(key .. value)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contact</span><span class="params">(str1, str2)</span></span></span><br><span class="line">    <span class="keyword">return</span> str1 .. str2</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(contact(<span class="string">"hello"</span>, <span class="string">"world"</span>))</span><br></pre></td></tr></table></figure>
<h4 id="3-6-3-Redis中使用Lua"><a href="#3-6-3-Redis中使用Lua" class="headerlink" title="3.6.3 Redis中使用Lua"></a>3.6.3 Redis中使用Lua</h4><ul>
<li>eval<br>Redis 中执行<code>eval script key_num keys args</code>:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; eval 'return "hello " .. KEYS[1] .. ARGV[1]' 1 redis world</span><br></pre></td></tr></table></figure>
如果Lua 脚本较长，可以使用redis-cli —eval 直接执行文件</li>
<li>evalsha<br>首先将Lua脚本加载到Redis 服务端，得到该脚本的SHA1校验和，evalsha 使用SHA1 作为参数可以直接执行对应Lua脚本，避免每次发送Lua 脚本的开销<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli script load "$(cat lua_get.lua)"</span><br><span class="line">evalsha sha1_value key_num keys args</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-6-4-Lua的Redis-API"><a href="#3-6-4-Lua的Redis-API" class="headerlink" title="3.6.4 Lua的Redis API"></a>3.6.4 Lua的Redis API</h4><p>Lua 可以使用redis.call、redis.pcall  函数实现对Redis 的访问，两者区别是 redis.call 执行失败，脚本立即返回错误，redis.pcall 会忽略错误继续执行脚本<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis.call(<span class="string">"set"</span>, <span class="string">"hello"</span>, <span class="string">"world"</span>)</span><br><span class="line">redis.call(<span class="string">"get"</span>, <span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="3-6-5-Redis-如何管理Lua脚本"><a href="#3-6-5-Redis-如何管理Lua脚本" class="headerlink" title="3.6.5 Redis 如何管理Lua脚本"></a>3.6.5 Redis 如何管理Lua脚本</h4><ul>
<li><code>script load script</code>：将Lua 脚本加载到Redis内存中</li>
<li><code>script exists sha1</code>：判断sha1 是否已经加载到Redis内存中</li>
<li><code>script flush</code>：清除已经加载的所有Lua脚本</li>
<li><code>script kill</code>：用于杀掉正在执行的Lua脚本，Redis 提供了<code>lua-time-limit</code> 参数，默认是 5 秒，但只是当Lua 脚本时间超过<code>lua-time-limit</code> 后向其他命令调用发送BUSY 信号，并不会停止服务端和客户端的脚本执行。如果Lua脚本正在执行写操作，<code>script kill</code> 将不会生效，此时要么等待脚本结束要么使用 <code>shutdown save</code> 停掉Redis服务</li>
</ul>
<h3 id="3-7-Bitmaps"><a href="#3-7-Bitmaps" class="headerlink" title="3.7 Bitmaps"></a>3.7 Bitmaps</h3><ul>
<li>Bitmaps 不是一种数据结构，实际上就是字符串，但可以对字符串的位进行操作</li>
<li>Bitmaps Bitmaps 类似一个以位为单位的数组，数组的每个单位只能存储0和1，数组的下标在Bitmaps中叫偏移量</li>
</ul>
<h4 id="3-7-1-Bitmaps命令"><a href="#3-7-1-Bitmaps命令" class="headerlink" title="3.7.1 Bitmaps命令"></a>3.7.1 Bitmaps命令</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>setbit key offset value</td>
<td>设置值</td>
</tr>
<tr>
<td>getbit key offset</td>
<td>获取值</td>
</tr>
<tr>
<td>bitcount [start] [end]</td>
<td>获取Bitmaps 指定范围为 1 的个数</td>
</tr>
<tr>
<td>bitop op destkey key[key …]</td>
<td>Bitmaps间的运算: and、or、not、xor</td>
</tr>
<tr>
<td>bitpos key targetBit [start] [end]</td>
<td>计算Bitmaps中第一个值为targetBit的偏移量</td>
</tr>
</tbody>
</table>
</div>
<h3 id="3-8-HyperLogLog"><a href="#3-8-HyperLogLog" class="headerlink" title="3.8 HyperLogLog"></a>3.8 HyperLogLog</h3><p>HyperLogLog并不是一种新的数据结构（实际类型为字符串），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>pfadd key element [element …]</td>
<td>添加</td>
</tr>
<tr>
<td>pfcount key [key …]</td>
<td>去重计数，存在一定误差</td>
</tr>
<tr>
<td>pfmerge destkey sourcekey [sourcekey …]</td>
<td>合并</td>
</tr>
</tbody>
</table>
</div>
<p>在选择HyperLogLog 时，需要确认两点：</p>
<ul>
<li>只是为了计算独立总数，不需要获取单条数据</li>
<li>可以容忍一定误差</li>
</ul>
<h3 id="3-9-发布订阅"><a href="#3-9-发布订阅" class="headerlink" title="3.9 发布订阅"></a>3.9 发布订阅</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>publish channel message</td>
<td>发布消息</td>
</tr>
<tr>
<td>subscribe channel [channel …]</td>
<td>订阅消息</td>
</tr>
<tr>
<td>unsubscribe [channel [channel …]]</td>
<td>取消订阅</td>
</tr>
<tr>
<td>psubscribe pattern [pattern …]</td>
<td>按照模式订阅</td>
</tr>
<tr>
<td>punsubscribe [pattern [pattern …]]</td>
<td>按照模式取消订阅</td>
</tr>
<tr>
<td>pubsub channels [pattern]</td>
<td>查看活跃的频道</td>
</tr>
<tr>
<td>pubsub numsub [channel …]</td>
<td>查看频道订阅数</td>
</tr>
<tr>
<td>pubsub numpat</td>
<td>查看模式订阅数</td>
</tr>
</tbody>
</table>
</div>
<p>订阅命令的注意点：</p>
<ul>
<li>客户端执行订阅命令之后进入了了订阅状态，只能接收<code>subscribe</code>、<code>psubscribe</code>、<code>unsubscribe</code>、<code>punsubscribe</code>这四个命令</li>
<li>新开启的订阅客户端，无法接收到该频道之前的消息，因为Redis不会对发布的消息进行持久化</li>
</ul>
<p>活跃的频道是指当前频道至少有一个订阅者</p>
<h3 id="3-10-GEO（地理信息定位）"><a href="#3-10-GEO（地理信息定位）" class="headerlink" title="3.10 GEO（地理信息定位）"></a>3.10 GEO（地理信息定位）</h3><p>Redis3.2 版本提供了GEO功能。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>geoadd key longitude latitude member [longitude latitude memeber …]</td>
<td>增加地理位置信息</td>
</tr>
<tr>
<td>geopos key member [memeber …]</td>
<td>获取地理位置信息</td>
</tr>
<tr>
<td>geodist key member1 member2 [unit]</td>
<td>获取两个地理位置的距离</td>
</tr>
<tr>
<td>georadius key longitude latitude radiusm &#124; km &#124; ft &#124; mi [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key]</td>
<td>获取指定位置范围内的地理信息位置集合</td>
</tr>
<tr>
<td>georadiusbymember key member (radiusm km ft mi) [withcoord] [withdist] [withhash] [COUNT count] [asc desc] [store key] [storedist key]</td>
<td>获取指定位置范围内的成员信息</td>
</tr>
<tr>
<td>geohash key member [member …]</td>
<td>获取geohash</td>
</tr>
<tr>
<td>zrem key member</td>
<td>删除地理位置信息</td>
</tr>
</tbody>
</table>
</div>
<p>参数：</p>
<ul>
<li>withcoord：返回结果中包含经纬度</li>
<li>withdist：返回结果中包含离中心节点位置的距离</li>
<li>withhash：返回结果中包含geohash</li>
<li>COUNT count：指定返回结果的数量</li>
<li>asc&#124;desc：返回结果按照离中心节点的距离做升序或者降序</li>
<li>store key：将返回结果的地理位置信息保存到指定键</li>
<li>storedist key: 将返回结果离中心节点的距离保存到指定键</li>
</ul>
<p><code>geohash</code>的特点：</p>
<ul>
<li>GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中</li>
<li>字符串越长，表示的位置更精确</li>
<li>两个字符串越相似，它们之间的距离越近</li>
<li>geohash编码和经纬度是可以互换的</li>
</ul>
<h2 id="四、客户端"><a href="#四、客户端" class="headerlink" title="四、客户端"></a>四、客户端</h2><h3 id="4-1-客户端通信协议"><a href="#4-1-客户端通信协议" class="headerlink" title="4.1 客户端通信协议"></a>4.1 客户端通信协议</h3><ol>
<li>客户端与服务器端之间的通信协议建立在TCP之上</li>
<li>Redis制定了RESP（REdis Serialization Protocol）</li>
</ol>
<p>命令格式（CRLF：<code>\r\n</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*&lt;参数数量&gt; CRLF</span><br><span class="line">$&lt;参数1的字节数量&gt; CRLF</span><br><span class="line">&lt;参数&gt; CRLF</span><br><span class="line">$&lt;参数N的字节数量&gt; CRLF</span><br><span class="line">&lt;参数&gt; CRLF</span><br></pre></td></tr></table></figure>
<p>响应格式：</p>
<ul>
<li><code>+</code> ：状态回复</li>
<li><code>-</code> ：错误回复</li>
<li><code>:</code> ：整数回复</li>
<li><code>$</code> ：字符串回复</li>
<li><code>*</code> ：多条字符串回复</li>
</ul>
<h3 id="4-2-Java-客户端Jedis"><a href="#4-2-Java-客户端Jedis" class="headerlink" title="4.2 Java 客户端Jedis"></a>4.2 Java 客户端Jedis</h3><h4 id="4-2-1-连接池配置"><a href="#4-2-1-连接池配置" class="headerlink" title="4.2.1 连接池配置"></a>4.2.1 连接池配置</h4><div class="table-container">
<table>
<thead>
<tr>
<th>参数名</th>
<th>含义</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>maxActive</td>
<td>连接池最大连接数</td>
<td>8</td>
</tr>
<tr>
<td>maxIdle</td>
<td>连接池最大空闲的连接数</td>
<td>8</td>
</tr>
<tr>
<td>minIdle</td>
<td>连接池最少空闲的连接数</td>
<td>0</td>
</tr>
<tr>
<td>maxWaitMillis</td>
<td>当连接池资源用尽时的最大等待时间（毫秒）</td>
<td>-1:表示永远不超时</td>
</tr>
<tr>
<td>jmxEnabled</td>
<td>是否开启jmx 监控，如果应用开启了jmx端口并且jmxEnabled 设置为true，可以通过jconsole 或者 jvisualvm 看到连接池的统计信息</td>
<td>true</td>
</tr>
<tr>
<td>minEvictableIdleTimeMillis</td>
<td>做空闲连接检测时，每次的采样数</td>
<td>3</td>
</tr>
<tr>
<td>testOnBorrow</td>
<td>向连接池借用连接时是否做连接有效性检测（ping），无效连接会被移除，每次归还还多执行一次ping 命令</td>
<td>false</td>
</tr>
<tr>
<td>testWhileIdle</td>
<td>向连接池借用连接时是否做空闲检测，空闲超时的连接会被移除</td>
<td>false</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td>空闲连接的检测周期（毫秒）</td>
<td>-1:表示不做检测</td>
</tr>
<tr>
<td>blockWhenExhausted</td>
<td>当连接池用尽后，调用者是否要等待，当此参数为true时，maxWaitMillis 才会生效</td>
<td>true</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-3-客户端管理"><a href="#4-3-客户端管理" class="headerlink" title="4.3 客户端管理"></a>4.3 客户端管理</h3><h4 id="4-3-1-客户端API"><a href="#4-3-1-客户端API" class="headerlink" title="4.3.1 客户端API"></a>4.3.1 客户端API</h4><p><code>client list</code>：列出与Redis 服务端相连的所有客户端连接信息</p>
<ul>
<li>id：客户端连接的唯一标识，随着Redis 的连接自增，重启Redis 后重置为 0</li>
<li>addr：客户端连接的ip 和端口</li>
<li>fd：socket的文件描述符，如果fd=-1代表客户端不是外部的，而是Redis内部的伪装客户端</li>
<li>name：客户端的名字</li>
<li>qbuf：输入缓冲区的总容量，输入缓冲区不受maxmemory 控制</li>
<li>qbuf-free：输入缓冲区的剩余容量 </li>
<li>obl：固定输出缓冲区的长度（16KB），使用字节数组，用于返回比较小的执行结果</li>
<li>oll：动态输出缓冲区的长度，使用列表，用于返回比较大的结果</li>
<li>omem：输出缓冲区一共使用的字节数</li>
</ul>
<p>Redis 没有提供相应的配置来规定每个缓冲区的大小，输入缓冲区会根据输入内容大小动态调整，只是要求每个客户端缓冲区的大小不能超过 1 G，超过后将被关闭。与输入缓冲区不同的是，输出缓冲区的容量可以通过<code>client-output-buffer-limit</code> 来进行设置：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>&lt;class&gt;：客户端类型：normal：普通客户端；slave：slave客户端；pubsub：发布订阅客户端</li>
<li>&lt;hard limit&gt;：如果客户端使用的输出缓冲区大于&lt;hard limit&gt;，客户端会被立即关闭</li>
<li>&lt;soft limit&gt; &lt;soft seconds&gt;：如果客户端使用的输出缓冲区超过了 &lt;soft limit&gt; 并持续了 &lt;soft limit&gt; 秒，客户端会被立即关闭</li>
</ul>
<h3 id="4-4-客户端常见异常"><a href="#4-4-客户端常见异常" class="headerlink" title="4.4 客户端常见异常"></a>4.4 客户端常见异常</h3><ol>
<li>无法从连接池获取到连接：<ul>
<li>连接池中没有可用的连接并且等待了<code>maxWaitMillis</code> 后也无可用连接</li>
<li>设置了<code>blockWhenExhausted=false</code> ，当连接池无可用连接直接抛出异常</li>
</ul>
</li>
<li>客户端读写超时：<ul>
<li>读写时间设置过短</li>
<li>命令本身比较慢</li>
<li>客户端与服务器端网络不正常</li>
<li>Redis自身发生阻塞</li>
</ul>
</li>
<li>客户端连接超时：<ul>
<li>连接超时时间过短</li>
<li>Redis发生阻塞，造成<code>tcp-backlog</code> 已满，造成新的连接失败</li>
<li>客户端与服务器端网络不正常</li>
</ul>
</li>
<li>客户端缓冲区异常：<ul>
<li>输出缓冲区满</li>
<li>长时间闲置被服务器端主动断开</li>
<li>不正常并发读写</li>
</ul>
</li>
<li>Lua脚本正在执行</li>
<li>Redis正在加载持久化文件</li>
<li>Redis使用的内存超过了<code>maxmemory</code> </li>
<li>客户端连接数过大</li>
</ol>
<h2 id="五、持久化"><a href="#五、持久化" class="headerlink" title="五、持久化"></a>五、持久化</h2><h3 id="5-1-RDB"><a href="#5-1-RDB" class="headerlink" title="5.1 RDB"></a>5.1 RDB</h3><h4 id="5-1-1-触发机制"><a href="#5-1-1-触发机制" class="headerlink" title="5.1.1 触发机制"></a>5.1.1 触发机制</h4><ul>
<li>手动触发<ul>
<li><code>save</code>：阻塞当前服务器，直到RDB过程完成为止</li>
<li><code>bgsave</code>： fork子进程，RDB持久化过程由子进程完成</li>
</ul>
</li>
<li>自动触发<ul>
<li>使用<code>save m n</code> 配置，m 秒内数据集存在n 次修改，自动触发bgsave</li>
<li>从节点执行全量复制操作，主节点自动执行<code>bgsave</code> 生成RDB文件发送给从节点</li>
<li>执行<code>debug reload</code> 命令重新加载Redis时，也会自动触发<code>save</code> 操作</li>
<li>默认情况下执行<code>shutdown</code> 命令时，如果没有开启AOF持久化功能则自动执行<code>bgsave</code> </li>
</ul>
</li>
</ul>
<h4 id="5-1-2-RDB的优缺点"><a href="#5-1-2-RDB的优缺点" class="headerlink" title="5.1.2 RDB的优缺点"></a>5.1.2 RDB的优缺点</h4><p>优点：</p>
<ul>
<li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照，适用于备份，全量复制</li>
<li>Redis加载RDB恢复数据远比AOF的方式快</li>
</ul>
<p>缺点：</p>
<ul>
<li>RDB没办法做到实时持久化/秒级持久化，因为<code>bgsave</code> 每次运行都要fork子进程，成本过高</li>
<li>RDB使用特定二进制格式保存，可能存在老旧版本Redis无法兼容的问题</li>
</ul>
<h3 id="5-2-AOF"><a href="#5-2-AOF" class="headerlink" title="5.2 AOF"></a>5.2 AOF</h3><p>开启AOF功能：<code>appendonly yes</code> ，默认不开启</p>
<p>AOF的工作流程：</p>
<ul>
<li>文件写入：所有的写入命令会追加到aof_buf（缓冲区）中，AOF命令写入的内容是文本协议格式</li>
<li>文件同步：AOF缓冲区根据对应的策略向硬盘做同步操作</li>
<li>文件重写：随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的</li>
<li>重启加载：当Redis重启时，可以加载AOF文件进行数据恢复</li>
</ul>
<p>文件同步策略：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>命令写入aof_buf后调用系统fsync同步到AOF文件，fsync完成后线程返回</td>
</tr>
<tr>
<td>everysec</td>
<td>命令写入aof_buf后调用系统write操作，write完成后线程返回，fsync由专门的线程每秒执行一次</td>
</tr>
<tr>
<td>no</td>
<td>命令写入aof_buf后调用系统write操作，不对AOF文件做fsync操作</td>
</tr>
</tbody>
</table>
</div>
<p>系统调用write和fsync区别：</p>
<ul>
<li>write 会触发延迟写机制，系统缓冲区同步至硬盘依赖于系统调度机制。</li>
<li>fsync针对单个文件操作，做强制硬盘同步，fsync将阻塞知道写入硬盘完成后返回</li>
</ul>
<p>触发AOF重写：</p>
<ul>
<li>手动触发：直接调用<code>bgrewriteaof</code> </li>
<li>自动触发：根据<code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewrite-percentage</code> 参数确定触发时机</li>
</ul>
<p><code>auto-aof-rewrite-min-size</code> ：表示运行AOF重写时文件最小体积，默认64M</p>
<p><code>auto-aof-rewrite-percentage</code> ：当前AOF文件空间（oaf_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值</p>
<p>自动触发时机=<code>aof_current_size&gt;auto-aof-rewrite-min-sieze &amp;&amp; (aof_current_size - aof_base_size)/aof_base_size &gt;= auto-aof-rewrite_percentage</code> </p>
<h3 id="5-3-重启加载"><a href="#5-3-重启加载" class="headerlink" title="5.3 重启加载"></a>5.3 重启加载</h3><div id="flowchart-0" class="flow-chart"></div>

<h2 id="六、面试"><a href="#六、面试" class="headerlink" title="六、面试"></a>六、面试</h2><h3 id="6-1-过期数据的删除策略"><a href="#6-1-过期数据的删除策略" class="headerlink" title="6.1 过期数据的删除策略"></a>6.1 过期数据的删除策略</h3><ol>
<li>惰性删除：只会在取出key的时候对数据进行过期检查。</li>
<li>定期删除：每过一段时间抽取一批key进行过期检查。</li>
</ol>
<p>redis采用的是定期删除+惰性删除</p>
<h3 id="6-2-6种内存淘汰策略"><a href="#6-2-6种内存淘汰策略" class="headerlink" title="6.2 6种内存淘汰策略"></a>6.2 6种内存淘汰策略</h3><ol>
<li>volatile-lru（last recent use）：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集中任意挑选数据淘汰</li>
<li>allkeys-lru（last recent use）：在键空间中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random：从数据集中任意挑选数据淘汰</li>
<li>no-eviction：禁止驱逐，内存不足时，新写入报错</li>
</ol>
<p>4.0 版本新增：</p>
<ol>
<li>volatile-lfu（last frequent use）：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰</li>
<li>allkeys-lfu：从键空间中挑选最不经常使用的数据淘汰</li>
</ol>
<h3 id="6-3-缓存穿透"><a href="#6-3-缓存穿透" class="headerlink" title="6.3 缓存穿透"></a>6.3 缓存穿透</h3><p>大量请求的key不存在缓存中，导致请求全部落在了数据库上。</p>
<p>解决办法：</p>
<ol>
<li>缓存无效的key</li>
<li>布隆过滤器</li>
</ol>
<h3 id="6-4-缓存雪崩"><a href="#6-4-缓存雪崩" class="headerlink" title="6.4 缓存雪崩"></a>6.4 缓存雪崩</h3><p>同一时间大面积失效，请求直接落在了数据库上。</p>
<p>解决办法：</p>
<ol>
<li>随机设置失效时间</li>
<li>限流</li>
</ol>
<p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Redis启动
fail=>end: 启动失败
success=>end: 启动成功
open_AOF=>condition: 开启AOF？
exists_AOF=>condition: 存在AOF？
exists_RDB=>condition: 存在RDB？
load_AOF=>operation: 加载AOF
load_RDB=>operation: 加载RDB
is_success=>condition: 成功？

st->open_AOF
open_AOF(yes)->exists_AOF
exists_AOF(yes)->load_AOF->is_success
exists_AOF(no)->exists_RDB
open_AOF(no)->exists_RDB
exists_RDB(yes)->load_RDB->is_success
is_success(yes)->success
is_success(no)->fail</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2020/04/20/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/" rel="next" title="算法导论">
      算法导论 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、初识Redis"><span class="nav-text">一、初识Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-Redis特性"><span class="nav-text">1.1 Redis特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-用好Redis的建议"><span class="nav-text">1.2 用好Redis的建议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-Redis-基本操作"><span class="nav-text">1.3 Redis 基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-配置、启动、操作、关闭"><span class="nav-text">1.3.1 配置、启动、操作、关闭</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、API的理解和使用"><span class="nav-text">二、API的理解和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-全局命令"><span class="nav-text">2.1 全局命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-数据结构和内部编码"><span class="nav-text">2.2 数据结构和内部编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-单线程架构"><span class="nav-text">2.3 单线程架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-字符串"><span class="nav-text">2.4 字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-字符串类型常用命令"><span class="nav-text">2.4.1 字符串类型常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-字符串类型不常用命令"><span class="nav-text">2.4.2 字符串类型不常用命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3-字符串内部编码"><span class="nav-text">2.4.3 字符串内部编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-哈希"><span class="nav-text">2.5 哈希</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-哈希命令"><span class="nav-text">2.5.1 哈希命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-内部编码"><span class="nav-text">2.5.2 内部编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-列表"><span class="nav-text">2.6 列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-列表的两个特点："><span class="nav-text">2.6.1 列表的两个特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-命令"><span class="nav-text">2.6.2 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-3-内部编码"><span class="nav-text">2.6.3 内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-4-使用场景"><span class="nav-text">2.6.4 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-集合"><span class="nav-text">2.7 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-1-命令"><span class="nav-text">2.7.1 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2-内部编码"><span class="nav-text">2.7.2 内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-3-使用场景"><span class="nav-text">2.7.3 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-有序集合"><span class="nav-text">2.8 有序集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-1-命令"><span class="nav-text">2.8.1 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-2-内部编码"><span class="nav-text">2.8.2 内部编码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-3-使用场景"><span class="nav-text">2.8.3 使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-键管理"><span class="nav-text">2.9 键管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-1-单个键管理"><span class="nav-text">2.9.1 单个键管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-2-遍历键"><span class="nav-text">2.9.2 遍历键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-3-数据库管理"><span class="nav-text">2.9.3 数据库管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、小功能大用处"><span class="nav-text">三、小功能大用处</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-慢查询分析"><span class="nav-text">3.1 慢查询分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-redis-cli-详解"><span class="nav-text">3.2 redis-cli 详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-redis-server-详解"><span class="nav-text">3.3 redis-server 详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-redis-benchmark-详解"><span class="nav-text">3.4 redis-benchmark 详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Pipeline"><span class="nav-text">3.5 Pipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-事务与Lua"><span class="nav-text">3.6 事务与Lua</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1-不同错误下的处理机制"><span class="nav-text">3.6.1 不同错误下的处理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2-Lua"><span class="nav-text">3.6.2 Lua</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3-Redis中使用Lua"><span class="nav-text">3.6.3 Redis中使用Lua</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-4-Lua的Redis-API"><span class="nav-text">3.6.4 Lua的Redis API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-5-Redis-如何管理Lua脚本"><span class="nav-text">3.6.5 Redis 如何管理Lua脚本</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-Bitmaps"><span class="nav-text">3.7 Bitmaps</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-1-Bitmaps命令"><span class="nav-text">3.7.1 Bitmaps命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-HyperLogLog"><span class="nav-text">3.8 HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9-发布订阅"><span class="nav-text">3.9 发布订阅</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10-GEO（地理信息定位）"><span class="nav-text">3.10 GEO（地理信息定位）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、客户端"><span class="nav-text">四、客户端</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-客户端通信协议"><span class="nav-text">4.1 客户端通信协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Java-客户端Jedis"><span class="nav-text">4.2 Java 客户端Jedis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-连接池配置"><span class="nav-text">4.2.1 连接池配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-客户端管理"><span class="nav-text">4.3 客户端管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1-客户端API"><span class="nav-text">4.3.1 客户端API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-客户端常见异常"><span class="nav-text">4.4 客户端常见异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、持久化"><span class="nav-text">五、持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-RDB"><span class="nav-text">5.1 RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1-触发机制"><span class="nav-text">5.1.1 触发机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2-RDB的优缺点"><span class="nav-text">5.1.2 RDB的优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-AOF"><span class="nav-text">5.2 AOF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-重启加载"><span class="nav-text">5.3 重启加载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、面试"><span class="nav-text">六、面试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-过期数据的删除策略"><span class="nav-text">6.1 过期数据的删除策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-6种内存淘汰策略"><span class="nav-text">6.2 6种内存淘汰策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-缓存穿透"><span class="nav-text">6.3 缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-缓存雪崩"><span class="nav-text">6.4 缓存雪崩</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">supermoonie</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">14</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">supermoonie</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->

    

  

</body>
</html>
